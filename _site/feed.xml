<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-04-16T13:46:17+04:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">My super-duper dev blog</title><subtitle>This description is generated by AI. It&apos;s not real. But it&apos;s cool, isn&apos;t it?</subtitle><author><name>Anton Beluzhenko</name></author><entry><title type="html">Why `as unknown as Type` should be banned</title><link href="http://localhost:4000/typescript/2024/04/16/why-as-uknown-as-type-shoud-be-banned.html" rel="alternate" type="text/html" title="Why `as unknown as Type` should be banned" /><published>2024-04-16T12:40:00+04:00</published><updated>2024-04-16T12:40:00+04:00</updated><id>http://localhost:4000/typescript/2024/04/16/why-as-uknown-as-type-shoud-be-banned</id><content type="html" xml:base="http://localhost:4000/typescript/2024/04/16/why-as-uknown-as-type-shoud-be-banned.html"><![CDATA[<p><img src="/assets/images/as-unknown-as-type.webp" alt="as-unknown-as-type" /></p>

<p>There is a common pattern in TypeScript codebases to use <code class="language-plaintext highlighter-rouge">as unknown as Type</code> for typecasting. I believe that this pattern should be banned. In this article, I will explain why.</p>

<!--more-->

<h3 id="unknown-type">Unknown type</h3>

<p>The unknown type was introduced in <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type">TypeScript 3.0</a> and it was expected to be a <a href="https://github.com/Microsoft/TypeScript/pull/24439">more type-safe alternative to <code class="language-plaintext highlighter-rouge">any</code></a></p>

<p>The crucial difference between the two is that the <code class="language-plaintext highlighter-rouge">unknown</code> is only assignable to itself, while the any doesn’t have such a limitation.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span><span class="p">:</span> <span class="nx">unknown</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">unknown</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">b</span><span class="p">:</span> <span class="kr">any</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">any</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">c</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>

<span class="c1">// Error: Type 'unknown' is not assignable to type 'string'</span>
<span class="nx">c</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>

<span class="c1">// Fine</span>
<span class="nx">c</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span>
</code></pre></div></div>

<p>The unknown type seems to be the best choice when we can’t be confident about a variable type:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">data</span><span class="p">:</span> <span class="nx">unknown</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">unsafeJson</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">result</span><span class="p">:</span> <span class="nx">uknown</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nx">externalCode</span><span class="p">);</span>
</code></pre></div></div>

<p>My rule of thumb here is that any external data has an unknown type by default until it is inferred. E.g.:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">isBarable</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="kr">any</span><span class="p">):</span> <span class="nx">value</span> <span class="k">is</span> <span class="p">{</span> <span class="na">bar</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span> <span class="p">}</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">value</span> <span class="o">&amp;&amp;</span> <span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span> <span class="k">in</span> <span class="nx">value</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">value</span><span class="p">.</span><span class="nx">bar</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">function</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">data</span><span class="p">:</span> <span class="nx">unknown</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">isBarable</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>See: <a href="https://learntypescript.dev/03/l7-unknown">Using the unknown type</a></p>
</blockquote>

<h3 id="misusing-unknown-type">Misusing <code class="language-plaintext highlighter-rouge">unknown</code> type</h3>

<p>Sometimes we could see a pattern <code class="language-plaintext highlighter-rouge">as unknown as Type</code> to be used for typecasting.
This is the most common misusage of the <code class="language-plaintext highlighter-rouge">unknown</code> type.
In this case <code class="language-plaintext highlighter-rouge">as unknown as Type</code> works exactly the same way like <code class="language-plaintext highlighter-rouge">as any as Type</code>:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">a</span><span class="p">:</span> <span class="nx">TypeA</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="dl">"</span><span class="s2">a</span><span class="dl">"</span> <span class="p">};</span>
<span class="kd">const</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">TypeB</span> <span class="o">=</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="dl">"</span><span class="s2">b</span><span class="dl">"</span> <span class="p">};</span>

<span class="c1">// These two are equivalent for the purpose of typecasting</span>
<span class="nx">a</span> <span class="o">=</span> <span class="nx">b</span> <span class="k">as</span> <span class="nx">unknown</span> <span class="k">as</span> <span class="nx">TypeA</span><span class="p">;</span>
<span class="nx">a</span> <span class="o">=</span> <span class="nx">b</span> <span class="k">as</span> <span class="kr">any</span> <span class="k">as</span> <span class="nx">TypeA</span><span class="p">;</span>
</code></pre></div></div>

<p>In the first step, a variable <code class="language-plaintext highlighter-rouge">b</code> is converted to <code class="language-plaintext highlighter-rouge">unknown</code> and then, to <code class="language-plaintext highlighter-rouge">any</code>.
We already know that the only difference between the two is that <code class="language-plaintext highlighter-rouge">unknown</code> can’t be assigned to any known type without type inference of casting. And the casting here is crucial. Since both <code class="language-plaintext highlighter-rouge">any</code> and <code class="language-plaintext highlighter-rouge">unknown</code> can be type-casted to anything, this last part of the expression just annihilates this difference.
This approach could even suggested by a TSServer as a “solution” for non-overlapping types casting:</p>

<p><img src="/assets/images/as-unknown-as-type-tsserver-suggestion.webp" alt="TSServer suggestion" /></p>

<p>It seems like a hacky way to use <code class="language-plaintext highlighter-rouge">any</code> without <code class="language-plaintext highlighter-rouge">any</code>, when the <code class="language-plaintext highlighter-rouge">es-lint</code> <code class="language-plaintext highlighter-rouge">no-explicit-any</code> rule is set.</p>

<p><img src="/assets/images/as-unknown-as-type-meme.webp" alt="As uknowns Scooby meme" /></p>

<blockquote>
  <p>If you’re confused about these “non-overlapping types conversion” errors, that’s completely fine, they’re confusing.
Here is an article that should help: <a href="/typescript/2024/02/24/understanding-ts-typecasting.html">Understanding TS type casting</a></p>
</blockquote>

<p>But while the usage of <code class="language-plaintext highlighter-rouge">any</code> requires us to explicitly disable the rule, <code class="language-plaintext highlighter-rouge">as unknown as Type</code> doesn’t.
Hence, it isn’t so easily trackable. Also, using both approaches in a single codebase makes the code less consistent:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// rules disables are easy to track</span>
<span class="c1">// eslint-disable-next-line @typescript-eslint/no-explicit-any</span>
<span class="nx">a</span> <span class="o">=</span> <span class="nx">b</span> <span class="k">as</span> <span class="kr">any</span> <span class="k">as</span> <span class="nx">TypeA</span><span class="p">;</span>

<span class="c1">// a bit harder to track</span>
<span class="nx">a</span> <span class="o">=</span> <span class="nx">b</span> <span class="k">as</span> <span class="nx">unknown</span> <span class="k">as</span> <span class="nx">TypeA</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="typecasting-problem">Typecasting problem</h3>

<p>One may say, that the problem here isn’t an approach for types casting, but the casting itself.
One of the goals of a type system is to prevent errors in the earliest stages. Using type casts we create blind spots, unreachable for checking and just deprive a type system from doing its job properly.
This way we may end up with a useless type system along with an obligation to write types.
When a type system seems useless for developers, it doesn’t incentivize them to write quality typings, and the vicious circle is closing.</p>

<p>But sometimes, casting is necessary. Let’s take, for example, a unit-test code:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Bar</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">bar</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">mock</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">bar</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{},</span>
<span class="p">}</span> <span class="k">as</span> <span class="nx">Bar</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">mock</span><span class="p">);</span>

<span class="nx">expect</span><span class="p">(</span><span class="nx">result</span><span class="p">).</span><span class="nx">toBeTruthy</span><span class="p">();</span>
</code></pre></div></div>

<p>We use typecasting to pass a simple mock to the tested function. The mock contains only the fields that are necessary for the test case and we don’t need its type to be strictly equal to the one, expected by the function. So, the typecasting seems rational so far.</p>

<p>But then we need to check if some method of the passed object is called, so we change the mock by assigning a <code class="language-plaintext highlighter-rouge">jest.fn()</code> to the appropriate field:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">mock</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">bar</span><span class="p">:</span> <span class="nx">jest</span><span class="p">.</span><span class="nx">fn</span><span class="p">(),</span>
<span class="p">}</span> <span class="k">as</span> <span class="nx">Bar</span><span class="p">;</span>

<span class="nx">foo</span><span class="p">(</span><span class="nx">mock</span><span class="p">);</span>

<span class="nx">expect</span><span class="p">(</span><span class="nx">mock</span><span class="p">.</span><span class="nx">bar</span><span class="p">).</span><span class="nx">toHaveBeenCalled</span><span class="p">();</span>
</code></pre></div></div>

<p>This change leads to the following error:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Conversion of type '{ bar: jest.Mock&lt;any, any, any&gt;; }' to type 'Bar' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
Property 'name' is missing in type '{ bar: jest.Mock&lt;any, any, any&gt;; }' but required in type 'Bar'.ts(2352)
</code></pre></div></div>

<p>Of course, we could add a <code class="language-plaintext highlighter-rouge">name</code> property to the mock, even if we don’t expect it to be read in this particular case, but in most cases it isn’t that simple:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">el</span> <span class="o">=</span> <span class="p">{</span> <span class="na">testId</span><span class="p">:</span> <span class="dl">"</span><span class="s2">testId</span><span class="dl">"</span> <span class="p">}</span> <span class="k">as</span> <span class="nx">HTMLElement</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Conversion of type '{ testId: string; }' to type 'HTMLElement' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
Type '{ testId: string; }' is missing the following properties from type 'HTMLElement': accessKey, accessKeyLabel, autocapitalize, dir, and 290 more.
</code></pre></div></div>

<p>There is nothing easier than just to follow the suggestion and cast the mock to <code class="language-plaintext highlighter-rouge">unknown</code> first, which may seem like an appropriate solution right now but creates a breach in the type system’s defense.</p>

<p>Imagine, someone would decide to refactor the type and change its signature renaming one of the argument fields.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Bar</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>

  <span class="c1">// old field</span>
  <span class="c1">// bar: () =&gt; void</span>

  <span class="c1">// new field</span>
  <span class="nl">fooBar</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// no type errors</span>
<span class="kd">const</span> <span class="nx">mock</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">bar</span><span class="p">:</span> <span class="nx">jest</span><span class="p">.</span><span class="nx">fn</span><span class="p">(),</span>
<span class="p">}</span> <span class="k">as</span> <span class="nx">unknown</span> <span class="k">as</span> <span class="nx">Bar</span><span class="p">;</span>
</code></pre></div></div>

<p>Hopefully, the test is going to fail, but the type check still passes. This way we just have disabled the first line of defense. Since unit tests are always slower than a type check, the feedback time for a developer is increased.
This is one of the plenty of tiny pitfalls that could spoil DX and increase TTM.</p>

<h3 id="summary">Summary</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">unknown</code> is a legal way to put some data into an “untyped leprosarium”. There is the only way to get out of there: type inference;</li>
  <li>using <code class="language-plaintext highlighter-rouge">an any as Type</code> instead of <code class="language-plaintext highlighter-rouge">as unknown as Type</code> is a more explicit way to say that there is a hacky type-casting;</li>
  <li>both options make the code less maintainable. It is always worth checking why types do not overlap when they are supposed to;</li>
</ul>]]></content><author><name>Anton Beluzhenko</name></author><category term="typescript" /><category term="typescript" /><category term="type-casting" /><category term="unknown" /><summary type="html"><![CDATA[There is a common pattern in TypeScript codebases to use as unknown as Type for typecasting. I believe that this pattern should be banned. In this article, I will explain why.]]></summary></entry><entry><title type="html">Understanding TypeScript typecasting</title><link href="http://localhost:4000/typescript/2024/02/24/understanding-ts-typecasting.html" rel="alternate" type="text/html" title="Understanding TypeScript typecasting" /><published>2024-02-24T13:52:32+04:00</published><updated>2024-02-24T13:52:32+04:00</updated><id>http://localhost:4000/typescript/2024/02/24/understanding-ts-typecasting</id><content type="html" xml:base="http://localhost:4000/typescript/2024/02/24/understanding-ts-typecasting.html"><![CDATA[<p><img src="/assets/images/understanding-ts-typecasting.webp" alt="type-casting" /></p>

<blockquote>
  <p>Disclaimer: typecasts lead to losing type information, I’d strongly recommend avoiding them, whenever possible.</p>
</blockquote>

<p>There are cases when typecasting is necessary or even preferable.</p>

<!--more-->

<p>For example, that could be casting mocks in tests. Let’s take a function that accepts an HTML element and sets up some attributes:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">setElementAttributes</span><span class="p">(</span><span class="nx">element</span><span class="p">:</span> <span class="nx">HTMLElement</span><span class="p">):</span> <span class="k">void</span><span class="p">;</span>
</code></pre></div></div>

<p>Assuming, we want to cover it with some unit tests. And, for some reason, we need to validate its behavior to be sure that appropriate methods were called with expected arguments. It seems rational to mock an argument of the function in a test case, instead of passing a real HTML element:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="p">{</span> <span class="na">setAttributes</span><span class="p">:</span> <span class="nx">jest</span><span class="p">.</span><span class="nx">fn</span><span class="p">()</span> <span class="p">}</span> <span class="k">as</span> <span class="nx">HTMLElement</span><span class="p">;</span>

<span class="nx">setElementAttributes</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>

<span class="nx">expect</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">setAttributes</span><span class="p">).</span><span class="nx">toHaveBeenCalled</span><span class="p">();</span>
</code></pre></div></div>

<p>The mock contains just enough for this test case, but the code above generates the following TypeScript error:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Conversion of type '{ setAttribute: jest.Mock&lt;any, any, any&gt;; }'
to type 'HTMLElement'may be a mistake because neither type
sufficiently overlaps with the other.
If this was intentional, convert the expression to 'unknown' first.

Type '{ setAttribute: Mock&lt;any, any, any&gt;; }' is missing the following
properties from type 'HTMLElement': accessKey, accessKeyLabel, autocapitalize,
dir, and 289 more.
</code></pre></div></div>

<blockquote>
  <p>The typecasting mechanism has sitting belts: TS doesn’t allow typecasting for non-overlapping types.</p>
</blockquote>

<p>It may be very appealing just to follow the suggestion above and add <code class="language-plaintext highlighter-rouge">as unknown</code> before casting the mock to the expected type:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="p">{</span> <span class="na">setAttributes</span><span class="p">:</span> <span class="nx">jest</span><span class="p">.</span><span class="nx">fn</span><span class="p">()</span> <span class="p">}</span> <span class="k">as</span> <span class="nx">unknown</span> <span class="k">as</span> <span class="nx">HTMLElement</span><span class="p">;</span>
</code></pre></div></div>

<p>But this will disable any type checks for the object and it will be much harder to reflect future changes of the interface inside the test.</p>

<p>So, where does this TS error come from, and how do we deal with it? Isn’t that we, who are the masters of our code? How dare this TypeScript to object us?</p>

<p>To understand what is happening, let’s decompose how type-casting works in TypeScript.</p>

<p>Here are types <code class="language-plaintext highlighter-rouge">TypeA</code> and <code class="language-plaintext highlighter-rouge">TypeB</code>:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">TypeA</span> <span class="p">{</span>
    <span class="nl">a</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">TypeB</span> <span class="p">{</span>
    <span class="nl">b</span><span class="p">:</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s try to cast them to each other:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">a</span><span class="p">:</span> <span class="nx">TypeA</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="dl">"</span><span class="s2">a</span><span class="dl">"</span> <span class="p">};</span>
<span class="kd">const</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">TypeB</span> <span class="o">=</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="dl">"</span><span class="s2">b</span><span class="dl">"</span> <span class="p">};</span>

<span class="kd">const</span> <span class="nx">bToA</span> <span class="o">=</span> <span class="nx">b</span> <span class="k">as</span> <span class="nx">TypeA</span><span class="p">;</span> <span class="c1">// Error: types don't overlap</span>
</code></pre></div></div>

<p>We’re getting an error, saying the casting is invalid, since the types don’t overlap.</p>

<p>On the other hand, the following casting is valid:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">empty</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">as</span> <span class="nx">TypeA</span><span class="p">;</span> <span class="c1">// This is fine</span>
</code></pre></div></div>

<p>But when we add some field to an empty object, there is a type error again:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">notEmpty</span> <span class="o">=</span> <span class="p">{</span> <span class="na">extraField</span><span class="p">:</span> <span class="kc">true</span> <span class="p">}</span> <span class="k">as</span> <span class="nx">TypeA</span><span class="p">;</span> <span class="c1">// Error: types don't overlap</span>
</code></pre></div></div>

<p>That may seem a bit weird. Why an empty object can be type-casted into <code class="language-plaintext highlighter-rouge">TypeA</code>, but an object with some extra field can’t?</p>

<p>When we cast <code class="language-plaintext highlighter-rouge">TypeA to TypeB</code>, TS checks whether <code class="language-plaintext highlighter-rouge">TypeA</code> can be converted to <code class="language-plaintext highlighter-rouge">TypeB</code> <strong>or</strong> if <code class="language-plaintext highlighter-rouge">TypeB</code> can be converted to <code class="language-plaintext highlighter-rouge">TypeA</code>.</p>

<blockquote>
  <p>The conversion is impossible for types that <strong>are not overlapping</strong>. It means that <strong>no value can have both types simultaneously</strong>.</p>
</blockquote>

<p>In a case when both conversions are impossible, TS shows an error, that is related to the <strong>first</strong> conversion attempt, which could be really misleading:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Conversion of type '{ extraField: boolean; }' to type 'TypeA'
may be a mistake because neither type sufficiently overlaps with the other.
If this was intentional, convert the expression to 'unknown' first.

Property 'a' is missing in type '{ extraField: boolean; }' but required
in type 'TypeA'
</code></pre></div></div>

<blockquote>
  <p>There is a <a href="https://github.com/microsoft/TypeScript/issues/47361">suggestion to change this error message</a>, with more details.</p>
</blockquote>

<p>Let’s return to our example again:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">empty</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">as</span> <span class="nx">TypeA</span><span class="p">;</span>
</code></pre></div></div>

<p>Firstly, TS tries to convert an empty object to <code class="language-plaintext highlighter-rouge">TypeA</code>. These types are not compatible since the empty object missing a required field <code class="language-plaintext highlighter-rouge">a</code> from <code class="language-plaintext highlighter-rouge">TypeA</code>. Next, it tries to convert <code class="language-plaintext highlighter-rouge">TypeA</code> to <code class="language-plaintext highlighter-rouge">{}</code>. This is a valid conversion since <code class="language-plaintext highlighter-rouge">TypeA</code> could be considered as an empty object with some extra fields.</p>

<p>Now let’s add an extra field to our object:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">notEmpty</span> <span class="o">=</span> <span class="p">{</span> <span class="na">extraField</span><span class="p">:</span> <span class="kc">true</span> <span class="p">}</span> <span class="k">as</span> <span class="nx">TypeA</span><span class="p">;</span>
</code></pre></div></div>

<p>Again, TS tries to convert the object to <code class="language-plaintext highlighter-rouge">TypeA</code>. Since it is missing field <code class="language-plaintext highlighter-rouge">a</code> from <code class="language-plaintext highlighter-rouge">TypeA</code>, this conversion won’t work. The next step is the conversion of <code class="language-plaintext highlighter-rouge">TypeA</code> to <code class="language-plaintext highlighter-rouge">{extraField: true}</code> type. Since <code class="language-plaintext highlighter-rouge">TypeA</code> misses <code class="language-plaintext highlighter-rouge">extraField</code>, this conversion is also impossible, and TS says about it, but refers to the first conversion attempt:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Property 'a' is missing in type '{ extraField: boolean; }'
but required in type 'TypeA'
</code></pre></div></div>

<p>Keeping that in mind helps to understand TS complaints and fix them without unsafe type-casts:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">el</span> <span class="o">=</span> <span class="p">{</span> <span class="na">setAttributes</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{}</span> <span class="p">}</span> <span class="k">as</span> <span class="nx">HTMLElement</span><span class="p">;</span> <span class="c1">// Error</span>
</code></pre></div></div>

<p>The type of <code class="language-plaintext highlighter-rouge">setAttributes</code> is not assignable to an appropriate type of <code class="language-plaintext highlighter-rouge">HTMLElement</code>, since it lacks function parameters. An empty function can’t be type-casted into a parametrized one:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">el</span> <span class="o">=</span> <span class="p">{</span> <span class="na">setAttributes</span><span class="p">:</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{}</span> <span class="p">}</span> <span class="k">as</span> <span class="nx">HTMLElement</span><span class="p">;</span> <span class="c1">// Fine</span>
</code></pre></div></div>

<p>Just adding the parameters enables the casing and fixes the error. We don’t even need to add the parameter types since they will be inferred by TS.</p>

<p>But what about Jest mocks? We have started with an example of casting a mock object:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="p">{</span> <span class="na">setAttributes</span><span class="p">:</span> <span class="nx">jest</span><span class="p">.</span><span class="nx">fn</span><span class="p">()</span> <span class="p">}</span> <span class="k">as</span> <span class="nx">HTMLElement</span><span class="p">;</span>

<span class="nx">setElementAttributes</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>

<span class="nx">expect</span><span class="p">(</span><span class="nx">element</span><span class="p">.</span><span class="nx">setAttributes</span><span class="p">).</span><span class="nx">toHaveBeenCalled</span><span class="p">();</span>
</code></pre></div></div>

<p>Since jest’s <code class="language-plaintext highlighter-rouge">Mock</code> is not assignable to <code class="language-plaintext highlighter-rouge">(name: string, value: string) =&gt; void</code>, the type that <code class="language-plaintext highlighter-rouge">HTMLElement['setAttribute']</code> has, there is a type error. What can we do about it?</p>

<p>The first option is to use <code class="language-plaintext highlighter-rouge">jest.spyOn</code> to set up a mock:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="p">{</span> <span class="na">setAttributes</span><span class="p">:</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{}</span> <span class="p">}</span> <span class="k">as</span> <span class="nx">HTMLElement</span><span class="p">;</span>

<span class="nx">setElementAttributes</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">spy</span> <span class="o">=</span> <span class="nx">jest</span><span class="p">.</span><span class="nx">spyOn</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="dl">"</span><span class="s2">setAttributes</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<p>The second is to narrow the method’s type since <code class="language-plaintext highlighter-rouge">Mock</code> is convertible to any function:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">setAttributes</span><span class="p">:</span> <span class="nx">jest</span><span class="p">.</span><span class="nx">fn</span><span class="p">()</span> <span class="k">as</span> <span class="nx">HTMLElement</span><span class="p">[</span><span class="dl">"</span><span class="s2">setAttributes</span><span class="dl">"</span><span class="p">],</span>
<span class="p">}</span> <span class="k">as</span> <span class="nx">HTMLElement</span><span class="p">;</span>
</code></pre></div></div>

<p>Both options won’t require any unsafe typecasts and we aren’t going to lose any type data.</p>

<p>Of course, the examples here are simplified, and real-life cases could be much more tricky. Here’s a little hack that could make resolving typecasting issues a bit easier.</p>

<p>Because TS will always show an error hint related to the first conversion attempt, we can force it to show the more informative one, just by reverting an expression:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">FooBar</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">foo</span><span class="p">:</span> <span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">;</span>
  <span class="nl">bar</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span><span class="p">;</span>
  <span class="nl">fooBar</span><span class="p">:</span> <span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span> <span class="na">fooBar</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="mi">0</span> <span class="p">}</span> <span class="k">as</span> <span class="nx">FooBar</span><span class="p">;</span>
</code></pre></div></div>

<p>The error hint doesn’t make much sense:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Conversion of type '{ fooBar: () =&gt; number; }' to type 'FooBar'
may be a mistake because neither type sufficiently overlaps with the other.
If this was intentional, convert the expression to 'unknown' first.

Type '{ fooBar: () =&gt; number; }' is missing the following properties from type 'FooBar': foo, bar
</code></pre></div></div>

<p>Let’s revert to the expression:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The const isn't initialized, but let's ignore it</span>
<span class="kd">const</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">FooBar</span><span class="p">;</span>

<span class="c1">// TS error</span>
<span class="kd">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">b</span> <span class="k">as</span> <span class="p">{</span> <span class="na">fooBar</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="kr">number</span> <span class="p">};</span>
</code></pre></div></div>

<p>Now, we’ll check the error hint:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Conversion of type 'FooBar' to type '{ fooBar: () =&gt; number; }'
may be a mistake because neither type sufficiently overlaps with the other.
If this was intentional, convert the expression to 'unknown' first.

Types of property 'fooBar' are incompatible.
Type '(value: string) =&gt; number' is not comparable to type '() =&gt; number'.
Target signature provides too few arguments. Expected 1 or more, but got 0.
</code></pre></div></div>

<p>And this one is pointing to the issue we have - incompatible <code class="language-plaintext highlighter-rouge">fooBar</code> methods.</p>

<p>Understanding the logic behind the TypeScript typecasting mechanism can help us avoid unsafe casting in our code and keep it more reliable.</p>

<p>Use casts for good and good luck!</p>]]></content><author><name>Anton Beluzhenko</name></author><category term="typescript" /><category term="typescript" /><category term="type-casting" /><summary type="html"><![CDATA[Disclaimer: typecasts lead to losing type information, I’d strongly recommend avoiding them, whenever possible. There are cases when typecasting is necessary or even preferable.]]></summary></entry></feed>