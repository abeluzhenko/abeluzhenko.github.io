<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=c01c85efcd2750d7e46fc4a94b1ef8549f3994f0">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup theme-color -->
<!-- start theme color meta headers -->
<meta name="theme-color" content="#151515">
<meta name="msapplication-navbutton-color" content="#151515">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- end theme color meta headers -->


<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->


<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Why as unknown as Type should be banned | My super-duper dev blog</title>
<meta name="generator" content="Jekyll v3.9.5" />
<meta property="og:title" content="Why as unknown as Type should be banned" />
<meta name="author" content="Anton Beluzhenko" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="There is a common pattern in TypeScript codebases to use as unknown as Type for typecasting. I believe that this pattern should be banned. In this article, I will explain why." />
<meta property="og:description" content="There is a common pattern in TypeScript codebases to use as unknown as Type for typecasting. I believe that this pattern should be banned. In this article, I will explain why." />
<link rel="canonical" href="http://localhost:4000/typescript/2024/04/16/why-as-uknown-as-type-shoud-be-banned.html" />
<meta property="og:url" content="http://localhost:4000/typescript/2024/04/16/why-as-uknown-as-type-shoud-be-banned.html" />
<meta property="og:site_name" content="My super-duper dev blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-04-16T12:40:00+04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Why as unknown as Type should be banned" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Anton Beluzhenko"},"dateModified":"2024-04-16T12:40:00+04:00","datePublished":"2024-04-16T12:40:00+04:00","description":"There is a common pattern in TypeScript codebases to use as unknown as Type for typecasting. I believe that this pattern should be banned. In this article, I will explain why.","headline":"Why as unknown as Type should be banned","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/typescript/2024/04/16/why-as-uknown-as-type-shoud-be-banned.html"},"url":"http://localhost:4000/typescript/2024/04/16/why-as-uknown-as-type-shoud-be-banned.html"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>

    <header>
      <div class="container">
        <a id="a-title" href="/">
          <h1>My super-duper dev blog</h1>
        </a>
        <h2>This description is generated by AI. It's not real. But it's cool, isn't it?</h2>

        <section id="downloads">
          
          <a href="https://github.com/abeluzhenko/abeluzhenko.github.io" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <small>16 April 2024</small>
<h1>Why `as unknown as Type` should be banned</h1>

<p class="view">by Anton Beluzhenko</p>

<p><img src="/assets/images/as-unknown-as-type.webp" alt="as-unknown-as-type" /></p>

<p>There is a common pattern in TypeScript codebases to use <code class="language-plaintext highlighter-rouge">as unknown as Type</code> for typecasting. I believe that this pattern should be banned. In this article, I will explain why.</p>

<!--more-->

<h3 id="unknown-type">Unknown type</h3>

<p>The unknown type was introduced in <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type">TypeScript 3.0</a> and it was expected to be a <a href="https://github.com/Microsoft/TypeScript/pull/24439">more type-safe alternative to <code class="language-plaintext highlighter-rouge">any</code></a></p>

<p>The crucial difference between the two is that the <code class="language-plaintext highlighter-rouge">unknown</code> is only assignable to itself, while the any doesn’t have such a limitation.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span><span class="p">:</span> <span class="nx">unknown</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">unknown</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">b</span><span class="p">:</span> <span class="kr">any</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">any</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">c</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>

<span class="c1">// Error: Type 'unknown' is not assignable to type 'string'</span>
<span class="nx">c</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>

<span class="c1">// Fine</span>
<span class="nx">c</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span>
</code></pre></div></div>

<p>The unknown type seems to be the best choice when we can’t be confident about a variable type:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">data</span><span class="p">:</span> <span class="nx">unknown</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">unsafeJson</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">result</span><span class="p">:</span> <span class="nx">uknown</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nx">externalCode</span><span class="p">);</span>
</code></pre></div></div>

<p>My rule of thumb here is that any external data has an unknown type by default until it is inferred. E.g.:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">isBarable</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="kr">any</span><span class="p">):</span> <span class="nx">value</span> <span class="k">is</span> <span class="p">{</span> <span class="na">bar</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span> <span class="p">}</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">value</span> <span class="o">&amp;&amp;</span> <span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span> <span class="k">in</span> <span class="nx">value</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">value</span><span class="p">.</span><span class="nx">bar</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">function</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">data</span><span class="p">:</span> <span class="nx">unknown</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">isBarable</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>See: <a href="https://learntypescript.dev/03/l7-unknown">Using the unknown type</a></p>
</blockquote>

<h3 id="misusing-unknown-type">Misusing <code class="language-plaintext highlighter-rouge">unknown</code> type</h3>

<p>Sometimes we could see a pattern <code class="language-plaintext highlighter-rouge">as unknown as Type</code> to be used for typecasting.
This is the most common misusage of the <code class="language-plaintext highlighter-rouge">unknown</code> type.
In this case <code class="language-plaintext highlighter-rouge">as unknown as Type</code> works exactly the same way like <code class="language-plaintext highlighter-rouge">as any as Type</code>:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">a</span><span class="p">:</span> <span class="nx">TypeA</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="dl">"</span><span class="s2">a</span><span class="dl">"</span> <span class="p">};</span>
<span class="kd">const</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">TypeB</span> <span class="o">=</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="dl">"</span><span class="s2">b</span><span class="dl">"</span> <span class="p">};</span>

<span class="c1">// These two are equivalent for the purpose of typecasting</span>
<span class="nx">a</span> <span class="o">=</span> <span class="nx">b</span> <span class="k">as</span> <span class="nx">unknown</span> <span class="k">as</span> <span class="nx">TypeA</span><span class="p">;</span>
<span class="nx">a</span> <span class="o">=</span> <span class="nx">b</span> <span class="k">as</span> <span class="kr">any</span> <span class="k">as</span> <span class="nx">TypeA</span><span class="p">;</span>
</code></pre></div></div>

<p>In the first step, a variable <code class="language-plaintext highlighter-rouge">b</code> is converted to <code class="language-plaintext highlighter-rouge">unknown</code> and then, to <code class="language-plaintext highlighter-rouge">any</code>.
We already know that the only difference between the two is that <code class="language-plaintext highlighter-rouge">unknown</code> can’t be assigned to any known type without type inference of casting. And the casting here is crucial. Since both <code class="language-plaintext highlighter-rouge">any</code> and <code class="language-plaintext highlighter-rouge">unknown</code> can be type-casted to anything, this last part of the expression just annihilates this difference.
This approach could even suggested by a TSServer as a “solution” for non-overlapping types casting:</p>

<p><img src="/assets/images/as-unknown-as-type-tsserver-suggestion.webp" alt="TSServer suggestion" /></p>

<p>It seems like a hacky way to use <code class="language-plaintext highlighter-rouge">any</code> without <code class="language-plaintext highlighter-rouge">any</code>, when the <code class="language-plaintext highlighter-rouge">es-lint</code> <code class="language-plaintext highlighter-rouge">no-explicit-any</code> rule is set.</p>

<p><img src="/assets/images/as-unknown-as-type-meme.webp" alt="As uknowns Scooby meme" /></p>

<blockquote>
  <p>If you’re confused about these “non-overlapping types conversion” errors, that’s completely fine, they’re confusing.
Here is an article that should help: <a href="/typescript/2024/02/24/understanding-ts-typecasting.html">Understanding TS type casting</a></p>
</blockquote>

<p>But while the usage of <code class="language-plaintext highlighter-rouge">any</code> requires us to explicitly disable the rule, <code class="language-plaintext highlighter-rouge">as unknown as Type</code> doesn’t.
Hence, it isn’t so easily trackable. Also, using both approaches in a single codebase makes the code less consistent:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// rules disables are easy to track</span>
<span class="c1">// eslint-disable-next-line @typescript-eslint/no-explicit-any</span>
<span class="nx">a</span> <span class="o">=</span> <span class="nx">b</span> <span class="k">as</span> <span class="kr">any</span> <span class="k">as</span> <span class="nx">TypeA</span><span class="p">;</span>

<span class="c1">// a bit harder to track</span>
<span class="nx">a</span> <span class="o">=</span> <span class="nx">b</span> <span class="k">as</span> <span class="nx">unknown</span> <span class="k">as</span> <span class="nx">TypeA</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="typecasting-problem">Typecasting problem</h3>

<p>One may say, that the problem here isn’t an approach for types casting, but the casting itself.
One of the goals of a type system is to prevent errors in the earliest stages. Using type casts we create blind spots, unreachable for checking and just deprive a type system from doing its job properly.
This way we may end up with a useless type system along with an obligation to write types.
When a type system seems useless for developers, it doesn’t incentivize them to write quality typings, and the vicious circle is closing.</p>

<p>But sometimes, casting is necessary. Let’s take, for example, a unit-test code:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Bar</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">bar</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">mock</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">bar</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{},</span>
<span class="p">}</span> <span class="k">as</span> <span class="nx">Bar</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">mock</span><span class="p">);</span>

<span class="nx">expect</span><span class="p">(</span><span class="nx">result</span><span class="p">).</span><span class="nx">toBeTruthy</span><span class="p">();</span>
</code></pre></div></div>

<p>We use typecasting to pass a simple mock to the tested function. The mock contains only the fields that are necessary for the test case and we don’t need its type to be strictly equal to the one, expected by the function. So, the typecasting seems rational so far.</p>

<p>But then we need to check if some method of the passed object is called, so we change the mock by assigning a <code class="language-plaintext highlighter-rouge">jest.fn()</code> to the appropriate field:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">mock</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">bar</span><span class="p">:</span> <span class="nx">jest</span><span class="p">.</span><span class="nx">fn</span><span class="p">(),</span>
<span class="p">}</span> <span class="k">as</span> <span class="nx">Bar</span><span class="p">;</span>

<span class="nx">foo</span><span class="p">(</span><span class="nx">mock</span><span class="p">);</span>

<span class="nx">expect</span><span class="p">(</span><span class="nx">mock</span><span class="p">.</span><span class="nx">bar</span><span class="p">).</span><span class="nx">toHaveBeenCalled</span><span class="p">();</span>
</code></pre></div></div>

<p>This change leads to the following error:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Conversion of type '{ bar: jest.Mock&lt;any, any, any&gt;; }' to type 'Bar' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
Property 'name' is missing in type '{ bar: jest.Mock&lt;any, any, any&gt;; }' but required in type 'Bar'.ts(2352)
</code></pre></div></div>

<p>Of course, we could add a <code class="language-plaintext highlighter-rouge">name</code> property to the mock, even if we don’t expect it to be read in this particular case, but in most cases it isn’t that simple:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">el</span> <span class="o">=</span> <span class="p">{</span> <span class="na">testId</span><span class="p">:</span> <span class="dl">"</span><span class="s2">testId</span><span class="dl">"</span> <span class="p">}</span> <span class="k">as</span> <span class="nx">HTMLElement</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Conversion of type '{ testId: string; }' to type 'HTMLElement' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.
Type '{ testId: string; }' is missing the following properties from type 'HTMLElement': accessKey, accessKeyLabel, autocapitalize, dir, and 290 more.
</code></pre></div></div>

<p>There is nothing easier than just to follow the suggestion and cast the mock to <code class="language-plaintext highlighter-rouge">unknown</code> first, which may seem like an appropriate solution right now but creates a breach in the type system’s defense.</p>

<p>Imagine, someone would decide to refactor the type and change its signature renaming one of the argument fields.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Bar</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>

  <span class="c1">// old field</span>
  <span class="c1">// bar: () =&gt; void</span>

  <span class="c1">// new field</span>
  <span class="nl">fooBar</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// no type errors</span>
<span class="kd">const</span> <span class="nx">mock</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">bar</span><span class="p">:</span> <span class="nx">jest</span><span class="p">.</span><span class="nx">fn</span><span class="p">(),</span>
<span class="p">}</span> <span class="k">as</span> <span class="nx">unknown</span> <span class="k">as</span> <span class="nx">Bar</span><span class="p">;</span>
</code></pre></div></div>

<p>Hopefully, the test is going to fail, but the type check still passes. This way we just have disabled the first line of defense. Since unit tests are always slower than a type check, the feedback time for a developer is increased.
This is one of the plenty of tiny pitfalls that could spoil DX and increase TTM.</p>

<h3 id="summary">Summary</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">unknown</code> is a legal way to put some data into an “untyped leprosarium”. There is the only way to get out of there: type inference;</li>
  <li>using <code class="language-plaintext highlighter-rouge">an any as Type</code> instead of <code class="language-plaintext highlighter-rouge">as unknown as Type</code> is a more explicit way to say that there is a hacky type-casting;</li>
  <li>both options make the code less maintainable. It is always worth checking why types do not overlap when they are supposed to;</li>
</ul>



  <small>tags: <em>typescript</em> - <em>type-casting</em> - <em>unknown</em></small>


      </section>
    </div>
  </body>
</html>
